#!/usr/bin/env python3
# -*- coding:utf-8 -*-
###
# File: /home/richard/sscp/model/str_seq_contrastive.py
# Project: /home/richard/sscp/model
# Created Date: Friday, December 9th 2022, 9:54:11 am
# Author: Ruochi Zhang
# Email: zrc720@gmail.com
# -----
# Last Modified: Fri Dec 09 2022
# Modified By: Ruochi Zhang
# -----
# Copyright (c) 2022 Bodkin World Domination Enterprises
#
# MIT License
#
# Copyright (c) 2022 Ruochi Zhang
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do
# so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# -----
###
from torch import nn
from torchdrug import core, layers
from model.helpers import Permute, Squeeze


class MultiviewContrast(nn.Module, core.Configurable):
    """
    Multiview Contrast proposed in `Protein Representation Learning by Geometric Structure Pretraining`

    Parameters:
        model_seq (nn.Module): node & graph representation model for sequential
        model_struc (nn.Module): node & graph representation model for structural data
        crop_funcs (list of nn.Module): list of cropping functions
        noise_funcs (list of nn.Module): list of noise functions
        out_dim(int, optional): output dimension of MLP layers
        activation (str or function, optional): activation function
        tau (float, optional): temperature in InfoNCE loss
    """

    eps = 1e-10

    def __init__(self,
                 model_seq,
                 model_struc,
                 crop_funcs,
                 noise_funcs,
                 out_dim=128,
                 activation="relu"):

        super(MultiviewContrast, self).__init__()
        self.model_seq = model_seq
        self.model_struc = model_struc
        self.crop_funcs = crop_funcs
        self.noise_funcs = noise_funcs

        self.pool = nn.Sequential(
            Permute(), nn.AdaptiveAvgPool1d(output_size=1),
            Squeeze(dim=-1))

        self.mlp_seq = layers.MLP(model_seq.output_dim,
                                  [model_seq.output_dim, out_dim],
                                  activation=activation)

        self.mlp_struc = layers.MLP(model_struc.output_dim,
                                    [model_struc.output_dim, out_dim],
                                    activation=activation)

    def forward(self, struc_input, seq_input):
        """
        Compute the graph representations of two augmented views.
        Each view is generated by randomly picking a cropping function and a noise function.
        Add the mutual information between two augmented views to the loss.

        Parameters:
            graph (Graph): :math:`n` graph(s)
            input (Tensor): input node representations

        Returns:
            dict with ``node_feature1``, ``node_feature2``, ``graph_feature1`` and ``graph_feature2`` fields:
                node representations of shape :math:`(|V|, d)`, graph representations of shape :math:`(n, d)`
                for two augmented views respectively
        """

        output1 = self.model_seq(struc_input, seq_input)["protein_feature"]
        output2 = self.model_struc(struc_input, struc_input.input)["graph_feature"]

        output = {
            "seq_rep": self.mlp_seq(output1),
            "struc_rep": self.mlp_struc(output2)
        }

        return output
