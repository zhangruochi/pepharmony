import copy
import random
import torch
from torch import nn
from torchdrug import core, layers


class MultiviewContrast(nn.Module, core.Configurable):
    """
    Multiview Contrast proposed in `Protein Representation Learning by Geometric Structure Pretraining`

    Parameters:
        model_seq (nn.Module): node & graph representation model for sequential
        model_struc (nn.Module): node & graph representation model for structural data
        crop_funcs (list of nn.Module): list of cropping functions
        noise_funcs (list of nn.Module): list of noise functions
        out_dim(int, optional): output dimension of MLP layers
        activation (str or function, optional): activation function
        tau (float, optional): temperature in InfoNCE loss
    """

    eps = 1e-10

    def __init__(self, model_seq, model_struc, crop_funcs, noise_funcs, out_dim=1024, activation="relu"):
        super(MultiviewContrast, self).__init__()
        self.model_seq = model_seq
        self.model_struc = model_struc
        self.crop_funcs = crop_funcs
        self.noise_funcs = noise_funcs

        self.mlp_seq = layers.MLP(model_seq.output_dim, [model_seq.output_dim, out_dim], activation=activation)
        # self.mlp_struc = layers.MLP(model_seq.output_dim, [model_seq.output_dim, out_dim], activation=activation)
        self.mlp_struc = layers.MLP(model_seq.output_dim, [model_struc.output_dim, out_dim], activation=activation)

    def forward(self, graph, input):
        """
        Compute the graph representations of two augmented views.
        Each view is generated by randomly picking a cropping function and a noise function.
        Add the mutual information between two augmented views to the loss.

        Parameters:
            graph (Graph): :math:`n` graph(s)
            input (Tensor): input node representations

        Returns:
            dict with ``node_feature1``, ``node_feature2``, ``graph_feature1`` and ``graph_feature2`` fields:
                node representations of shape :math:`(|V|, d)`, graph representations of shape :math:`(n, d)`
                for two augmented views respectively
        """
        # Get augmented views
        graph = copy.copy(graph)
        with graph.residue():
            graph.input = input
        noise_func1, noise_func2 = random.sample(self.noise_funcs, 1)[0], random.sample(self.noise_funcs, 1)[0]

        if len(self.crop_funcs):
            crop_func1, crop_func2 = random.sample(self.crop_funcs, 1)[0], random.sample(self.crop_funcs, 1)[0]
            graph1 = crop_func1(graph)
            graph2 = crop_func2(graph)
        else:
            graph1 = copy.copy(graph)
            graph2 = copy.copy(graph)

        graph1 = noise_func1(graph1)
        output1 = self.model_seq(graph1, graph1.input)

        graph2 = noise_func2(graph2)
        output2 = self.model_struc(graph2, graph2.input)


        output = {"residue_feature1": output1["residue_feature"], "graph_feature1": self.mlp_seq(output1["graph_feature"]),
                  "residue_feature2": output2["node_feature"], "graph_feature2": self.mlp_struc(output2["graph_feature"])}

        return output
